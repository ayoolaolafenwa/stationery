# -*- coding: utf-8 -*-
"""stationery_inference

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r-5ZoPZ1tJTJDWDagBbVTPVxydWdFcc_
"""

import keras
from keras.layers import *
from keras.models import *
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import LearningRateScheduler
import os
from keras.callbacks import ModelCheckpoint
from keras.optimizers import Adam
from keras.preprocessing import image



#linear bottle neck module
def LinearBottleNeck(x, in_channels,out_channels, stride, expansion):
#expansion of channels
    out = Conv2D(in_channels * expansion, kernel_size = 1, strides = 1, padding = "same", use_bias = False)(x)
    out = BatchNormalization()(out)
    out = Activation("relu6")(out)

#depthwise conv to apply filters channel by channel
    out = DepthwiseConv2D(kernel_size = 3, strides =  stride, padding = "same", use_bias = False)(out)
    out = BatchNormalization()(out)
    out = Activation("relu6")(out)

#reduce the output channels to reduce computational cost
    out = Conv2D(out_channels, kernel_size = 1, strides = 1, padding =  "same", use_bias = False)(out)
    out = BatchNormalization()(out)
    out = Activation("relu6")(out)

# res_like addition of first layer with final layer if image dimension == output dimension
    if stride == 1 and in_channels == out_channels:
        out = add([out, x])

    return out    


# relu6 function
def relu6(x):
    return K.relu(x, max_value = 6)



#model structure, a stack of linear bottle neck modules
def model_structure(input_shape, multiplier = 1.0, num_classes = 9):
    images = Input(input_shape)

#first layer in the block
    net = Conv2D(int(32 * multiplier), kernel_size = 3, strides = 2, padding = "same")(images)
    net = BatchNormalization()(net)
    net = Activation("relu")(net)

#first block with a 16 * multiplier output  and a stride of 1
    net = LinearBottleNeck(net, in_channels = int(32 * multiplier), out_channels = int(16 * multiplier), stride = 1, expansion = 1)


    #Second block with 24 * multplier output with first stride of 2
    net = LinearBottleNeck(net, in_channels=int(16 * multiplier), out_channels=int(24 * multiplier), stride=2, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(24 * multiplier), out_channels=int(24 * multiplier), stride=1, expansion=6)

    #Third block with 32 * multplier output with first stride of 2
    net = LinearBottleNeck(net, in_channels=int(24 * multiplier), out_channels=int(32 * multiplier), stride=2, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(32 * multiplier), out_channels=int(32 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(32 * multiplier), out_channels=int(32 * multiplier), stride=1, expansion=6)

    #Fourth block with 64 * multplier output with first stride of 2
    net = LinearBottleNeck(net, in_channels=int(32 * multiplier), out_channels=int(64 * multiplier), stride=2, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(64 * multiplier), out_channels=int(64 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(64 * multiplier), out_channels=int(64 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(64 * multiplier), out_channels=int(64 * multiplier), stride=1, expansion=6)

    #Fifth block with 96 * multplier output with first stride of 1
    net = LinearBottleNeck(net, in_channels=int(64 * multiplier), out_channels=int(96 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(96 * multiplier), out_channels=int(96 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(96 * multiplier), out_channels=int(96 * multiplier), stride=1, expansion=6)

    #Sixth block with 160 * multplier output with first stride of 2
    net = LinearBottleNeck(net, in_channels=int(96 * multiplier), out_channels=int(160 * multiplier), stride=2, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(160 * multiplier), out_channels=int(160 * multiplier), stride=1, expansion=6)
    net = LinearBottleNeck(net, in_channels=int(160 * multiplier), out_channels=int(160 * multiplier), stride=1, expansion=6)

    #Seventh block with 320 * multplier output with stride of 1
    net = LinearBottleNeck(net, in_channels=int(160 * multiplier), out_channels=int(320 * multiplier), stride=1, expansion=6)

#final_channels should be 1280
    if multiplier > 1.0:
        final_channels = 1280 * multiplier
    else:
        final_channels = 1280  

#expand output channels
    net = Conv2D(final_channels, kernel_size = 1, strides = 1, use_bias = False)(net)
    net = BatchNormalization()(net)
    net = Activation("relu6")(net)
    net = Dropout(0.30)

#reduce output channels to reduce computational cost

    net = AveragePooling2D(pool_size = (7,7))(net)
    net = Conv2D(num_classes, kernel_size = 1, strides = 1,  use_bias = False)(net)
    net = Flatten()(net)
    net = Activation("softmax")(net)

    model = Model(inputs = images, outputs = net)
    return model


def process_image(x):
    x *=  1./255
    return x

model = model_structure(input_shape = (224, 224, 3), num_classes = 9)
model.load_weights("stationery_model.039-0.6670506912442397.h5")
class_map = {0:""}



def predictImage(image_path):

    image_to_predict = image.load_img(image_path, target_size = (224, 224))
    image_to_predict = image.img_to_array(image_to_predict, data_format = "channels_last")
    image_to_predict = np.expand_dims(image_to_predict, axis = 0)

    image_to_predict = process_image(image_to_predict)
    prediction = model.predict(image_to_predict)

    predicted_class = prediction.argmax()
    prediction_confidence = prediction.max()

    image_class = class_map[predicted_class]

    print("Class Name: ", image_class)
    print("Confidence: ", prediction_confidence)

predictImage("sample.jpg")